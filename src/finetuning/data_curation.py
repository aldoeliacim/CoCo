"""
Human-in-the-Loop Panel Annotation Tool

This script provides an interactive interface for reviewing and approving
panel detections generated by the base YOLO model. Approved annotations
are saved for training data.
"""

import os
import sys
import json
import argparse
from pathlib import Path
from typing import List, Dict, Tuple
import cv2
import numpy as np
from PIL import Image
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog

# Standardized project imports
import config
from config import setup_logger, YOLO_PANEL_MODEL_PATH

from ultralytics import YOLO

logger = setup_logger("data_curation")


class PanelAnnotationTool:
    """Interactive tool for reviewing and approving panel detections."""

    def __init__(self, base_model_path: str, output_dir: str):
        self.base_model = YOLO(base_model_path)
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Create subdirectories
        (self.output_dir / "approved").mkdir(exist_ok=True)
        (self.output_dir / "rejected").mkdir(exist_ok=True)
        (self.output_dir / "annotations").mkdir(exist_ok=True)

        self.approved_count = 0
        self.rejected_count = 0
        self.current_image = None
        self.current_detections = None
        self.current_file = None

        # Initialize GUI
        self.setup_gui()

    def setup_gui(self):
        """Setup the tkinter GUI for annotation."""
        self.root = tk.Tk()
        self.root.title("Panel Annotation Tool - Human-in-the-Loop")
        self.root.geometry("1200x800")

        # Main frame
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padding=10)

        # Image display frame
        self.image_frame = ttk.Frame(main_frame)
        self.image_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # Controls frame
        controls_frame = ttk.Frame(main_frame, width=300)
        controls_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=(10, 0))
        controls_frame.pack_propagate(False)

        # Image label
        self.image_label = ttk.Label(self.image_frame)
        self.image_label.pack(expand=True)

        # Controls
        ttk.Label(controls_frame, text="Panel Detection Review",
                 font=("Arial", 14, "bold")).pack(pady=(0, 20))

        # Info display
        self.info_text = tk.Text(controls_frame, height=8, wrap=tk.WORD)
        self.info_text.pack(fill=tk.X, pady=(0, 20))

        # Buttons
        button_frame = ttk.Frame(controls_frame)
        button_frame.pack(fill=tk.X, pady=(0, 10))

        self.approve_btn = ttk.Button(button_frame, text="✅ Approve",
                                     command=self.approve_detection, state=tk.DISABLED)
        self.approve_btn.pack(fill=tk.X, pady=2)

        self.reject_btn = ttk.Button(button_frame, text="❌ Reject",
                                    command=self.reject_detection, state=tk.DISABLED)
        self.reject_btn.pack(fill=tk.X, pady=2)

        self.skip_btn = ttk.Button(button_frame, text="⏭️ Skip",
                                  command=self.skip_detection, state=tk.DISABLED)
        self.skip_btn.pack(fill=tk.X, pady=2)

        # Progress info
        self.progress_label = ttk.Label(controls_frame, text="Load images to start")
        self.progress_label.pack(pady=(20, 0))

        # Status
        self.status_label = ttk.Label(controls_frame, text="Ready")
        self.status_label.pack(pady=(10, 0))

    def load_images(self, image_dir: str):
        """Load images from directory for annotation."""
        image_files = []
        for ext in ['*.png', '*.jpg', '*.jpeg']:
            image_files.extend(Path(image_dir).glob(ext))

        if not image_files:
            messagebox.showerror("Error", f"No images found in {image_dir}")
            return

        logger.info(f"Found {len(image_files)} images for annotation")
        self.image_files = sorted(image_files)
        self.current_index = 0
        self.load_next_image()

    def load_next_image(self):
        """Load the next image and run panel detection."""
        if self.current_index >= len(self.image_files):
            self.annotation_complete()
            return

        self.current_file = self.image_files[self.current_index]
        logger.info(f"Processing: {self.current_file.name}")

        # Update status
        self.status_label.config(text=f"Processing {self.current_file.name}...")
        self.root.update()

        # Load image
        self.current_image = cv2.imread(str(self.current_file))
        if self.current_image is None:
            logger.error(f"Failed to load image: {self.current_file}")
            self.current_index += 1
            self.load_next_image()
            return

        # Run detection
        try:
            results = self.base_model(str(self.current_file))
            self.current_detections = results[0].boxes

            # Display image with detections
            self.display_image_with_detections()

            # Update info
            self.update_info_display()

            # Enable buttons
            self.approve_btn.config(state=tk.NORMAL)
            self.reject_btn.config(state=tk.NORMAL)
            self.skip_btn.config(state=tk.NORMAL)

            self.status_label.config(text="Review detections")

        except Exception as e:
            logger.error(f"Detection failed for {self.current_file}: {e}")
            self.current_index += 1
            self.load_next_image()

    def display_image_with_detections(self):
        """Display the current image with panel detections overlaid."""
        if self.current_image is None or self.current_detections is None:
            return

        # Create display image
        display_img = self.current_image.copy()

        # Draw detections
        if len(self.current_detections) > 0:
            for box in self.current_detections.xyxy:
                x1, y1, x2, y2 = map(int, box.cpu().numpy())
                cv2.rectangle(display_img, (x1, y1), (x2, y2), (0, 255, 0), 2)
                cv2.putText(display_img, "Panel", (x1, y1-10),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)

        # Resize for display
        height, width = display_img.shape[:2]
        max_height = 600
        if height > max_height:
            scale = max_height / height
            new_width = int(width * scale)
            display_img = cv2.resize(display_img, (new_width, max_height))

        # Convert to PhotoImage
        display_img_rgb = cv2.cvtColor(display_img, cv2.COLOR_BGR2RGB)
        img_pil = Image.fromarray(display_img_rgb)
        img_tk = tk.PhotoImage(img_pil)

        # Update label
        self.image_label.config(image=img_tk)
        self.image_label.image = img_tk  # Keep reference

    def update_info_display(self):
        """Update the information display."""
        info = f"File: {self.current_file.name}\n"
        info += f"Image: {self.current_index + 1}/{len(self.image_files)}\n"
        info += f"Detected Panels: {len(self.current_detections) if self.current_detections is not None else 0}\n"
        info += f"Approved: {self.approved_count}\n"
        info += f"Rejected: {self.rejected_count}\n\n"

        if self.current_detections is not None and len(self.current_detections) > 0:
            info += "Panel Coordinates:\n"
            for i, box in enumerate(self.current_detections.xyxy):
                x1, y1, x2, y2 = map(int, box.cpu().numpy())
                conf = self.current_detections.conf[i].item()
                info += f"{i+1}: ({x1},{y1}) - ({x2},{y2}) conf: {conf:.2f}\n"

        self.info_text.delete(1.0, tk.END)
        self.info_text.insert(1.0, info)

    def approve_detection(self):
        """Approve the current detection and save annotation."""
        if self.current_detections is None:
            return

        # Save annotation in YOLO format
        self.save_annotation("approved")
        self.approved_count += 1

        # Copy image to approved folder
        approved_path = self.output_dir / "approved" / self.current_file.name
        import shutil
        shutil.copy2(self.current_file, approved_path)

        logger.info(f"Approved: {self.current_file.name} ({len(self.current_detections)} panels)")
        self.next_image()

    def reject_detection(self):
        """Reject the current detection."""
        self.rejected_count += 1

        # Save to rejected folder for review
        rejected_path = self.output_dir / "rejected" / self.current_file.name
        import shutil
        shutil.copy2(self.current_file, rejected_path)

        logger.info(f"Rejected: {self.current_file.name}")
        self.next_image()

    def skip_detection(self):
        """Skip the current detection without saving."""
        logger.info(f"Skipped: {self.current_file.name}")
        self.next_image()

    def save_annotation(self, category: str):
        """Save annotation in YOLO format."""
        if self.current_detections is None or len(self.current_detections) == 0:
            return

        # Get image dimensions
        height, width = self.current_image.shape[:2]

        # Create annotation file
        annotation_file = self.output_dir / "annotations" / f"{self.current_file.stem}.txt"

        with open(annotation_file, 'w') as f:
            for box in self.current_detections.xyxy:
                x1, y1, x2, y2 = box.cpu().numpy()

                # Convert to YOLO format (normalized center x, center y, width, height)
                center_x = ((x1 + x2) / 2) / width
                center_y = ((y1 + y2) / 2) / height
                box_width = (x2 - x1) / width
                box_height = (y2 - y1) / height

                # Class 0 for panels
                f.write(f"0 {center_x:.6f} {center_y:.6f} {box_width:.6f} {box_height:.6f}\n")

        # Save metadata
        metadata = {
            "file": self.current_file.name,
            "category": category,
            "panels": len(self.current_detections),
            "dimensions": {"width": width, "height": height}
        }

        metadata_file = self.output_dir / "annotations" / f"{self.current_file.stem}.json"
        with open(metadata_file, 'w') as f:
            json.dump(metadata, f, indent=2)

    def next_image(self):
        """Move to the next image."""
        self.current_index += 1
        self.update_progress()
        self.load_next_image()

    def update_progress(self):
        """Update progress display."""
        progress = f"Progress: {self.current_index}/{len(self.image_files)}"
        self.progress_label.config(text=progress)

    def annotation_complete(self):
        """Handle completion of annotation process."""
        summary = f"Annotation Complete!\n\n"
        summary += f"Images processed: {len(self.image_files)}\n"
        summary += f"Approved: {self.approved_count}\n"
        summary += f"Rejected: {self.rejected_count}\n"
        summary += f"Skipped: {len(self.image_files) - self.approved_count - self.rejected_count}\n\n"
        summary += f"Annotations saved to: {self.output_dir / 'annotations'}"

        messagebox.showinfo("Complete", summary)
        logger.info("Annotation process completed")
        logger.info(f"Final stats - Approved: {self.approved_count}, Rejected: {self.rejected_count}")

        # Disable buttons
        self.approve_btn.config(state=tk.DISABLED)
        self.reject_btn.config(state=tk.DISABLED)
        self.skip_btn.config(state=tk.DISABLED)

        self.status_label.config(text="Annotation Complete!")


def main():
    parser = argparse.ArgumentParser(description="Human-in-the-Loop Panel Annotation Tool")
    parser.add_argument("--input", required=True, help="Input directory with comic page images")
    parser.add_argument("--output", required=True, help="Output directory for annotations")
    parser.add_argument("--model", default=str(YOLO_PANEL_MODEL_PATH),
                       help="Path to base YOLO model")

    args = parser.parse_args()

    if not Path(args.input).exists():
        print(f"Error: Input directory {args.input} does not exist")
        return 1

    if not Path(args.model).exists():
        print(f"Error: Model file {args.model} does not exist")
        print("Please run: python scripts/models_downloader.py")
        return 1

    print("🎯 Starting Human-in-the-Loop Panel Annotation Tool")
    print(f"📁 Input: {args.input}")
    print(f"💾 Output: {args.output}")
    print(f"🤖 Model: {args.model}")

    # Create annotation tool
    tool = PanelAnnotationTool(args.model, args.output)

    # Load images
    tool.load_images(args.input)

    # Start GUI
    print("\n🖥️  GUI launched - review and approve/reject panel detections")
    print("Instructions:")
    print("  ✅ Approve: Good panel detections (saves for training)")
    print("  ❌ Reject: Poor detections (excludes from training)")
    print("  ⏭️  Skip: Uncertain cases (no action)")

    tool.root.mainloop()

    return 0


if __name__ == "__main__":
    sys.exit(main())
